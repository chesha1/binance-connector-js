/**
 * Binance Public Spot REST API
 *
 * OpenAPI Specifications for the Binance Public Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AllOrderListResponse,
    AllOrdersResponse,
    DeleteOpenOrdersResponse,
    DeleteOrderListResponse,
    DeleteOrderResponse,
    GetOpenOrdersResponse,
    GetOrderListResponse,
    GetOrderResponse,
    NewOrderResponse,
    OpenOrderListResponse,
    OrderCancelReplaceResponse,
    OrderListOcoResponse,
    OrderListOtoResponse,
    OrderListOtocoResponse,
    OrderOcoResponse,
    SorOrderResponse,
    SorOrderTestResponse,
} from '../types';

/**
 * TradeApi - axios parameter creator
 */
const TradeApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Retrieves all order lists based on provided optional parameters.
         *
         * Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
         * Weight: 20
         *
         * @summary Query all Order lists
         * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        allOrderList: async (
            fromId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/allOrderList',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * Weight: 20
         *
         * @summary All orders
         * @param {string} symbol
         * @param {number} [orderId] This can only be used in combination with `symbol`.
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        allOrders: async (
            symbol: string,
            orderId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('allOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/allOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancels all active orders on a symbol.
         * This includes orders that are part of an order list.
         * Weight: 1
         *
         * @summary Cancel All Open Orders on a Symbol
         * @param {string} symbol
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        deleteOpenOrders: async (symbol: string, recvWindow?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOpenOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/openOrders',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an active order.
         * Weight: 1
         *
         * @summary Cancel order
         * @param {string} symbol
         * @param {number} [orderId] This can only be used in combination with `symbol`.
         * @param {string} [origClientOrderId] Either ```orderListId``` or ```listClientOrderId``` must be provided
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {DeleteOrderCancelRestrictionsEnum} [cancelRestrictions]
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        deleteOrder: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            newClientOrderId?: string,
            cancelRestrictions?: DeleteOrderCancelRestrictionsEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (cancelRestrictions !== undefined && cancelRestrictions !== null) {
                localVarQueryParameter['cancelRestrictions'] = cancelRestrictions;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an entire Order list
         * Weight: 1
         *
         * @summary Cancel Order list
         * @param {string} symbol
         * @param {number} [orderListId] Either```orderListId```or```listClientOrderId```mustbeprovided
         * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        deleteOrderList: async (
            symbol: string,
            orderListId?: number,
            listClientOrderId?: string,
            newClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrderList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderListId !== undefined && orderListId !== null) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
         * Weight: 6 for a single symbol; **80** when the symbol parameter is omitted
         *
         * @summary Current open orders
         * @param {string} symbol
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        getOpenOrders: async (symbol: string, recvWindow?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOpenOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/openOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Check an order's status.
         * Weight: 4
         *
         * @summary Query order
         * @param {string} symbol
         * @param {number} [orderId] This can only be used in combination with `symbol`.
         * @param {string} [origClientOrderId] Either ```orderListId``` or ```listClientOrderId``` must be provided
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        getOrder: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Retrieves a specific order list based on provided optional parameters.
         * Weight: 4
         *
         * @summary Query Order list
         * @param {number} [orderListId] Either```orderListId```or```listClientOrderId```mustbeprovided
         * @param {string} [origClientOrderId] Either ```orderListId``` or ```listClientOrderId``` must be provided
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        getOrderList: async (
            orderListId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (orderListId !== undefined && orderListId !== null) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in a new order.
         * Weight: 1
         *
         * @summary New order
         * @param {string} symbol
         * @param {number} quantity
         * @param {number} stopPrice
         * @param {NewOrderSideEnum} [side]
         * @param {NewOrderTypeEnum} [type]
         * @param {NewOrderTimeInForceEnum} [timeInForce]
         * @param {number} [quoteOrderQty]
         * @param {number} [price]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [strategyId]
         * @param {number} [strategyType] The value cannot be less than `1000000`.
         * @param {number} [trailingDelta]
         * @param {number} [icebergQty] Used with `LIMIT` to create an iceberg order.
         * @param {NewOrderNewOrderRespTypeEnum} [newOrderRespType]
         * @param {NewOrderSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        newOrder: async (
            symbol: string,
            quantity: number,
            stopPrice: number,
            side?: NewOrderSideEnum,
            type?: NewOrderTypeEnum,
            timeInForce?: NewOrderTimeInForceEnum,
            quoteOrderQty?: number,
            price?: number,
            newClientOrderId?: string,
            strategyId?: number,
            strategyType?: number,
            trailingDelta?: number,
            icebergQty?: number,
            newOrderRespType?: NewOrderNewOrderRespTypeEnum,
            selfTradePreventionMode?: NewOrderSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newOrder', 'symbol', symbol);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('newOrder', 'quantity', quantity);
            // verify required parameter 'stopPrice' is not null or undefined for certain order types
            if (type === NewOrderTypeEnum.STOP_LOSS ||
                type === NewOrderTypeEnum.STOP_LOSS_LIMIT ||
                type === NewOrderTypeEnum.TAKE_PROFIT ||
                type === NewOrderTypeEnum.TAKE_PROFIT_LIMIT) {
                assertParamExists('newOrder', 'stopPrice', stopPrice);
            }

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (quoteOrderQty !== undefined && quoteOrderQty !== null) {
                localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (strategyType !== undefined && strategyType !== null) {
                localVarQueryParameter['strategyType'] = strategyType;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (trailingDelta !== undefined && trailingDelta !== null) {
                localVarQueryParameter['trailingDelta'] = trailingDelta;
            }

            if (icebergQty !== undefined && icebergQty !== null) {
                localVarQueryParameter['icebergQty'] = icebergQty;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         *
         * Weight: 6
         *
         * @summary Query Open Order lists
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        openOrderList: async (recvWindow?: number): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/openOrderList',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancels an existing order and places a new order on the same symbol.
         *
         * Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
         *
         * A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED` ), will still increase the order count by 1.
         * Weight: 1
         *
         * @summary Cancel an Existing Order and Send a New Order
         * @param {string} symbol
         * @param {number} quantity
         * @param {number} stopPrice
         * @param {OrderCancelReplaceSideEnum} [side]
         * @param {OrderCancelReplaceTypeEnum} [type]
         * @param {OrderCancelReplaceCancelReplaceModeEnum} [cancelReplaceMode]
         * @param {OrderCancelReplaceTimeInForceEnum} [timeInForce]
         * @param {number} [quoteOrderQty]
         * @param {number} [price]
         * @param {string} [cancelNewClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {string} [cancelOrigClientOrderId] Either the `cancelOrigClientOrderId` or `cancelOrderId` must be provided. If both are provided, `cancelOrderId` takes precedence.
         * @param {number} [cancelOrderId] Either the `cancelOrigClientOrderId` or `cancelOrderId` must be provided. If both are provided, `cancelOrderId` takes precedence.
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [strategyId]
         * @param {number} [strategyType] The value cannot be less than `1000000`.
         * @param {number} [trailingDelta]
         * @param {number} [icebergQty] Used with `LIMIT` to create an iceberg order.
         * @param {OrderCancelReplaceNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderCancelReplaceSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {OrderCancelReplaceCancelRestrictionsEnum} [cancelRestrictions]
         * @param {OrderCancelReplaceOrderRateLimitExceededModeEnum} [orderRateLimitExceededMode]
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        orderCancelReplace: async (
            symbol: string,
            quantity: number,
            stopPrice: number,
            side?: OrderCancelReplaceSideEnum,
            type?: OrderCancelReplaceTypeEnum,
            cancelReplaceMode?: OrderCancelReplaceCancelReplaceModeEnum,
            timeInForce?: OrderCancelReplaceTimeInForceEnum,
            quoteOrderQty?: number,
            price?: number,
            cancelNewClientOrderId?: string,
            cancelOrigClientOrderId?: string,
            cancelOrderId?: number,
            newClientOrderId?: string,
            strategyId?: number,
            strategyType?: number,
            trailingDelta?: number,
            icebergQty?: number,
            newOrderRespType?: OrderCancelReplaceNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderCancelReplaceSelfTradePreventionModeEnum,
            cancelRestrictions?: OrderCancelReplaceCancelRestrictionsEnum,
            orderRateLimitExceededMode?: OrderCancelReplaceOrderRateLimitExceededModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderCancelReplace', 'symbol', symbol);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('orderCancelReplace', 'quantity', quantity);
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('orderCancelReplace', 'stopPrice', stopPrice);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (cancelReplaceMode !== undefined && cancelReplaceMode !== null) {
                localVarQueryParameter['cancelReplaceMode'] = cancelReplaceMode;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (quoteOrderQty !== undefined && quoteOrderQty !== null) {
                localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (cancelNewClientOrderId !== undefined && cancelNewClientOrderId !== null) {
                localVarQueryParameter['cancelNewClientOrderId'] = cancelNewClientOrderId;
            }

            if (cancelOrigClientOrderId !== undefined && cancelOrigClientOrderId !== null) {
                localVarQueryParameter['cancelOrigClientOrderId'] = cancelOrigClientOrderId;
            }

            if (cancelOrderId !== undefined && cancelOrderId !== null) {
                localVarQueryParameter['cancelOrderId'] = cancelOrderId;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (strategyType !== undefined && strategyType !== null) {
                localVarQueryParameter['strategyType'] = strategyType;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (trailingDelta !== undefined && trailingDelta !== null) {
                localVarQueryParameter['trailingDelta'] = trailingDelta;
            }

            if (icebergQty !== undefined && icebergQty !== null) {
                localVarQueryParameter['icebergQty'] = icebergQty;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (cancelRestrictions !== undefined && cancelRestrictions !== null) {
                localVarQueryParameter['cancelRestrictions'] = cancelRestrictions;
            }

            if (orderRateLimitExceededMode !== undefined && orderRateLimitExceededMode !== null) {
                localVarQueryParameter['orderRateLimitExceededMode'] = orderRateLimitExceededMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order/cancelReplace',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
         *
         * An OCO has 2 orders called the **above order** and **below order**.
         * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
         * Price restrictions
         * If the OCO is on the `SELL` side:
         * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
         * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
         * If the OCO is on the `BUY` side:
         * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
         * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
         * OCOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter, and the `MAX_NUM_ORDERS` filter.
         * Weight: 1
         *
         * @summary New Order list - OCO
         * @param {string} symbol
         * @param {number} quantity
         * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
         * @param {OrderListOcoSideEnum} [side]
         * @param {OrderListOcoAboveTypeEnum} [aboveType]
         * @param {string} [aboveClientOrderId] Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
         * @param {number} [aboveIcebergQty] Note that this can only be used if `aboveTimeInForce` is `GTC`.
         * @param {number} [abovePrice] Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
         * @param {number} [aboveStopPrice] Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT` <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
         * @param {number} [aboveTrailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
         * @param {number} [aboveTimeInForce] Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`
         * @param {number} [aboveStrategyId] Arbitrary numeric value identifying the above order within an order strategy.
         * @param {number} [aboveStrategyType] Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
         * @param {OrderListOcoBelowTypeEnum} [belowType]
         * @param {string} [belowClientOrderId] Arbitrary unique ID among open orders for the below order. Automatically generated if not sent
         * @param {number} [belowIcebergQty] Note that this can only be used if `belowTimeInForce` is `GTC`.
         * @param {number} [belowPrice] Can be used if `belowType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
         * @param {number} [belowStopPrice] Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT` or `TAKE_PROFIT_LIMIT` <br>Either belowStopPrice or belowTrailingDelta or both, must be specified.
         * @param {number} [belowTrailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
         * @param {OrderListOcoBelowTimeInForceEnum} [belowTimeInForce]
         * @param {number} [belowStrategyId] Arbitrary numeric value identifying the below order within an order strategy.
         * @param {number} [belowStrategyType] Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
         * @param {OrderListOcoNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderListOcoSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        orderListOco: async (
            symbol: string,
            quantity: number,
            listClientOrderId?: string,
            side?: OrderListOcoSideEnum,
            aboveType?: OrderListOcoAboveTypeEnum,
            aboveClientOrderId?: string,
            aboveIcebergQty?: number,
            abovePrice?: number,
            aboveStopPrice?: number,
            aboveTrailingDelta?: number,
            aboveTimeInForce?: number,
            aboveStrategyId?: number,
            aboveStrategyType?: number,
            belowType?: OrderListOcoBelowTypeEnum,
            belowClientOrderId?: string,
            belowIcebergQty?: number,
            belowPrice?: number,
            belowStopPrice?: number,
            belowTrailingDelta?: number,
            belowTimeInForce?: OrderListOcoBelowTimeInForceEnum,
            belowStrategyId?: number,
            belowStrategyType?: number,
            newOrderRespType?: OrderListOcoNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderListOcoSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderListOco', 'symbol', symbol);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('orderListOco', 'quantity', quantity);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (aboveType !== undefined && aboveType !== null) {
                localVarQueryParameter['aboveType'] = aboveType;
            }

            if (aboveClientOrderId !== undefined && aboveClientOrderId !== null) {
                localVarQueryParameter['aboveClientOrderId'] = aboveClientOrderId;
            }

            if (aboveIcebergQty !== undefined && aboveIcebergQty !== null) {
                localVarQueryParameter['aboveIcebergQty'] = aboveIcebergQty;
            }

            if (abovePrice !== undefined && abovePrice !== null) {
                localVarQueryParameter['abovePrice'] = abovePrice;
            }

            if (aboveStopPrice !== undefined && aboveStopPrice !== null) {
                localVarQueryParameter['aboveStopPrice'] = aboveStopPrice;
            }

            if (aboveTrailingDelta !== undefined && aboveTrailingDelta !== null) {
                localVarQueryParameter['aboveTrailingDelta'] = aboveTrailingDelta;
            }

            if (aboveTimeInForce !== undefined && aboveTimeInForce !== null) {
                localVarQueryParameter['aboveTimeInForce'] = aboveTimeInForce;
            }

            if (aboveStrategyId !== undefined && aboveStrategyId !== null) {
                localVarQueryParameter['aboveStrategyId'] = aboveStrategyId;
            }

            if (aboveStrategyType !== undefined && aboveStrategyType !== null) {
                localVarQueryParameter['aboveStrategyType'] = aboveStrategyType;
            }

            if (belowType !== undefined && belowType !== null) {
                localVarQueryParameter['belowType'] = belowType;
            }

            if (belowClientOrderId !== undefined && belowClientOrderId !== null) {
                localVarQueryParameter['belowClientOrderId'] = belowClientOrderId;
            }

            if (belowIcebergQty !== undefined && belowIcebergQty !== null) {
                localVarQueryParameter['belowIcebergQty'] = belowIcebergQty;
            }

            if (belowPrice !== undefined && belowPrice !== null) {
                localVarQueryParameter['belowPrice'] = belowPrice;
            }

            if (belowStopPrice !== undefined && belowStopPrice !== null) {
                localVarQueryParameter['belowStopPrice'] = belowStopPrice;
            }

            if (belowTrailingDelta !== undefined && belowTrailingDelta !== null) {
                localVarQueryParameter['belowTrailingDelta'] = belowTrailingDelta;
            }

            if (belowTimeInForce !== undefined && belowTimeInForce !== null) {
                localVarQueryParameter['belowTimeInForce'] = belowTimeInForce;
            }

            if (belowStrategyId !== undefined && belowStrategyId !== null) {
                localVarQueryParameter['belowStrategyId'] = belowStrategyId;
            }

            if (belowStrategyType !== undefined && belowStrategyType !== null) {
                localVarQueryParameter['belowStrategyType'] = belowStrategyType;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList/oco',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Places an OTO.
         *
         * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
         * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
         * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
         * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
         * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
         * OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
         * Weight: 1
         *
         * @summary New Order list - OTO
         * @param {string} symbol
         * @param {number} workingPrice
         * @param {number} workingQuantity
         * @param {number} pendingQuantity
         * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
         * @param {OrderListOtoNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderListOtoSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {OrderListOtoWorkingTypeEnum} [workingType]
         * @param {OrderListOtoWorkingSideEnum} [workingSide]
         * @param {string} [workingClientOrderId] Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
         * @param {number} [workingIcebergQty] This can only be used if `workingTimeInForce` is `GTC`.
         * @param {OrderListOtoWorkingTimeInForceEnum} [workingTimeInForce]
         * @param {number} [workingStrategyId] Arbitrary numeric value identifying the working order within an order strategy.
         * @param {number} [workingStrategyType] Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {OrderListOtoPendingTypeEnum} [pendingType]
         * @param {OrderListOtoPendingSideEnum} [pendingSide]
         * @param {string} [pendingClientOrderId] Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
         * @param {number} [pendingPrice]
         * @param {number} [pendingStopPrice]
         * @param {number} [pendingTrailingDelta]
         * @param {number} [pendingIcebergQty] This can only be used if `pendingTimeInForce` is `GTC` or if `pendingType` is `LIMIT_MAKER`.
         * @param {OrderListOtoPendingTimeInForceEnum} [pendingTimeInForce]
         * @param {number} [pendingStrategyId] Arbitrary numeric value identifying the pending order within an order strategy.
         * @param {number} [pendingStrategyType] Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        orderListOto: async (
            symbol: string,
            workingPrice: number,
            workingQuantity: number,
            pendingQuantity: number,
            listClientOrderId?: string,
            newOrderRespType?: OrderListOtoNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderListOtoSelfTradePreventionModeEnum,
            workingType?: OrderListOtoWorkingTypeEnum,
            workingSide?: OrderListOtoWorkingSideEnum,
            workingClientOrderId?: string,
            workingIcebergQty?: number,
            workingTimeInForce?: OrderListOtoWorkingTimeInForceEnum,
            workingStrategyId?: number,
            workingStrategyType?: number,
            pendingType?: OrderListOtoPendingTypeEnum,
            pendingSide?: OrderListOtoPendingSideEnum,
            pendingClientOrderId?: string,
            pendingPrice?: number,
            pendingStopPrice?: number,
            pendingTrailingDelta?: number,
            pendingIcebergQty?: number,
            pendingTimeInForce?: OrderListOtoPendingTimeInForceEnum,
            pendingStrategyId?: number,
            pendingStrategyType?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderListOto', 'symbol', symbol);
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('orderListOto', 'workingPrice', workingPrice);
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('orderListOto', 'workingQuantity', workingQuantity);
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('orderListOto', 'pendingQuantity', pendingQuantity);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }

            if (workingSide !== undefined && workingSide !== null) {
                localVarQueryParameter['workingSide'] = workingSide;
            }

            if (workingClientOrderId !== undefined && workingClientOrderId !== null) {
                localVarQueryParameter['workingClientOrderId'] = workingClientOrderId;
            }

            if (workingPrice !== undefined && workingPrice !== null) {
                localVarQueryParameter['workingPrice'] = workingPrice;
            }

            if (workingQuantity !== undefined && workingQuantity !== null) {
                localVarQueryParameter['workingQuantity'] = workingQuantity;
            }

            if (workingIcebergQty !== undefined && workingIcebergQty !== null) {
                localVarQueryParameter['workingIcebergQty'] = workingIcebergQty;
            }

            if (workingTimeInForce !== undefined && workingTimeInForce !== null) {
                localVarQueryParameter['workingTimeInForce'] = workingTimeInForce;
            }

            if (workingStrategyId !== undefined && workingStrategyId !== null) {
                localVarQueryParameter['workingStrategyId'] = workingStrategyId;
            }

            if (workingStrategyType !== undefined && workingStrategyType !== null) {
                localVarQueryParameter['workingStrategyType'] = workingStrategyType;
            }

            if (pendingType !== undefined && pendingType !== null) {
                localVarQueryParameter['pendingType'] = pendingType;
            }

            if (pendingSide !== undefined && pendingSide !== null) {
                localVarQueryParameter['pendingSide'] = pendingSide;
            }

            if (pendingClientOrderId !== undefined && pendingClientOrderId !== null) {
                localVarQueryParameter['pendingClientOrderId'] = pendingClientOrderId;
            }

            if (pendingPrice !== undefined && pendingPrice !== null) {
                localVarQueryParameter['pendingPrice'] = pendingPrice;
            }

            if (pendingStopPrice !== undefined && pendingStopPrice !== null) {
                localVarQueryParameter['pendingStopPrice'] = pendingStopPrice;
            }

            if (pendingTrailingDelta !== undefined && pendingTrailingDelta !== null) {
                localVarQueryParameter['pendingTrailingDelta'] = pendingTrailingDelta;
            }

            if (pendingQuantity !== undefined && pendingQuantity !== null) {
                localVarQueryParameter['pendingQuantity'] = pendingQuantity;
            }

            if (pendingIcebergQty !== undefined && pendingIcebergQty !== null) {
                localVarQueryParameter['pendingIcebergQty'] = pendingIcebergQty;
            }

            if (pendingTimeInForce !== undefined && pendingTimeInForce !== null) {
                localVarQueryParameter['pendingTimeInForce'] = pendingTimeInForce;
            }

            if (pendingStrategyId !== undefined && pendingStrategyId !== null) {
                localVarQueryParameter['pendingStrategyId'] = pendingStrategyId;
            }

            if (pendingStrategyType !== undefined && pendingStrategyType !== null) {
                localVarQueryParameter['pendingStrategyType'] = pendingStrategyType;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList/oto',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Place an OTOCO.
         *
         * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
         *
         * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
         * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
         * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
         * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
         * OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
         * Weight: 1
         *
         * @summary New Order list - OTOCO
         * @param {string} symbol
         * @param {number} workingPrice
         * @param {number} workingQuantity
         * @param {number} pendingQuantity
         * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
         * @param {OrderListOtocoNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderListOtocoSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {OrderListOtocoWorkingTypeEnum} [workingType]
         * @param {OrderListOtocoWorkingSideEnum} [workingSide]
         * @param {string} [workingClientOrderId] Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
         * @param {number} [workingIcebergQty] This can only be used if `workingTimeInForce` is `GTC`.
         * @param {OrderListOtocoWorkingTimeInForceEnum} [workingTimeInForce]
         * @param {number} [workingStrategyId] Arbitrary numeric value identifying the working order within an order strategy.
         * @param {number} [workingStrategyType] Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {OrderListOtocoPendingSideEnum} [pendingSide]
         * @param {OrderListOtocoPendingAboveTypeEnum} [pendingAboveType]
         * @param {string} [pendingAboveClientOrderId] Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
         * @param {number} [pendingAbovePrice] Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
         * @param {number} [pendingAboveStopPrice] Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
         * @param {number} [pendingAboveTrailingDelta] See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
         * @param {number} [pendingAboveIcebergQty] This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
         * @param {OrderListOtocoPendingAboveTimeInForceEnum} [pendingAboveTimeInForce]
         * @param {number} [pendingAboveStrategyId] Arbitrary numeric value identifying the pending above order within an order strategy.
         * @param {number} [pendingAboveStrategyType] Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {OrderListOtocoPendingBelowTypeEnum} [pendingBelowType]
         * @param {string} [pendingBelowClientOrderId] Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
         * @param {number} [pendingBelowPrice] Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify limit price
         * @param {number} [pendingBelowStopPrice] Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br> Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
         * @param {number} [pendingBelowTrailingDelta]
         * @param {number} [pendingBelowIcebergQty] This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
         * @param {OrderListOtocoPendingBelowTimeInForceEnum} [pendingBelowTimeInForce]
         * @param {number} [pendingBelowStrategyId] Arbitrary numeric value identifying the pending below order within an order strategy.
         * @param {number} [pendingBelowStrategyType] Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        orderListOtoco: async (
            symbol: string,
            workingPrice: number,
            workingQuantity: number,
            pendingQuantity: number,
            listClientOrderId?: string,
            newOrderRespType?: OrderListOtocoNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderListOtocoSelfTradePreventionModeEnum,
            workingType?: OrderListOtocoWorkingTypeEnum,
            workingSide?: OrderListOtocoWorkingSideEnum,
            workingClientOrderId?: string,
            workingIcebergQty?: number,
            workingTimeInForce?: OrderListOtocoWorkingTimeInForceEnum,
            workingStrategyId?: number,
            workingStrategyType?: number,
            pendingSide?: OrderListOtocoPendingSideEnum,
            pendingAboveType?: OrderListOtocoPendingAboveTypeEnum,
            pendingAboveClientOrderId?: string,
            pendingAbovePrice?: number,
            pendingAboveStopPrice?: number,
            pendingAboveTrailingDelta?: number,
            pendingAboveIcebergQty?: number,
            pendingAboveTimeInForce?: OrderListOtocoPendingAboveTimeInForceEnum,
            pendingAboveStrategyId?: number,
            pendingAboveStrategyType?: number,
            pendingBelowType?: OrderListOtocoPendingBelowTypeEnum,
            pendingBelowClientOrderId?: string,
            pendingBelowPrice?: number,
            pendingBelowStopPrice?: number,
            pendingBelowTrailingDelta?: number,
            pendingBelowIcebergQty?: number,
            pendingBelowTimeInForce?: OrderListOtocoPendingBelowTimeInForceEnum,
            pendingBelowStrategyId?: number,
            pendingBelowStrategyType?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderListOtoco', 'symbol', symbol);
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('orderListOtoco', 'workingPrice', workingPrice);
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('orderListOtoco', 'workingQuantity', workingQuantity);
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('orderListOtoco', 'pendingQuantity', pendingQuantity);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }

            if (workingSide !== undefined && workingSide !== null) {
                localVarQueryParameter['workingSide'] = workingSide;
            }

            if (workingClientOrderId !== undefined && workingClientOrderId !== null) {
                localVarQueryParameter['workingClientOrderId'] = workingClientOrderId;
            }

            if (workingPrice !== undefined && workingPrice !== null) {
                localVarQueryParameter['workingPrice'] = workingPrice;
            }

            if (workingQuantity !== undefined && workingQuantity !== null) {
                localVarQueryParameter['workingQuantity'] = workingQuantity;
            }

            if (workingIcebergQty !== undefined && workingIcebergQty !== null) {
                localVarQueryParameter['workingIcebergQty'] = workingIcebergQty;
            }

            if (workingTimeInForce !== undefined && workingTimeInForce !== null) {
                localVarQueryParameter['workingTimeInForce'] = workingTimeInForce;
            }

            if (workingStrategyId !== undefined && workingStrategyId !== null) {
                localVarQueryParameter['workingStrategyId'] = workingStrategyId;
            }

            if (workingStrategyType !== undefined && workingStrategyType !== null) {
                localVarQueryParameter['workingStrategyType'] = workingStrategyType;
            }

            if (pendingSide !== undefined && pendingSide !== null) {
                localVarQueryParameter['pendingSide'] = pendingSide;
            }

            if (pendingQuantity !== undefined && pendingQuantity !== null) {
                localVarQueryParameter['pendingQuantity'] = pendingQuantity;
            }

            if (pendingAboveType !== undefined && pendingAboveType !== null) {
                localVarQueryParameter['pendingAboveType'] = pendingAboveType;
            }

            if (pendingAboveClientOrderId !== undefined && pendingAboveClientOrderId !== null) {
                localVarQueryParameter['pendingAboveClientOrderId'] = pendingAboveClientOrderId;
            }

            if (pendingAbovePrice !== undefined && pendingAbovePrice !== null) {
                localVarQueryParameter['pendingAbovePrice'] = pendingAbovePrice;
            }

            if (pendingAboveStopPrice !== undefined && pendingAboveStopPrice !== null) {
                localVarQueryParameter['pendingAboveStopPrice'] = pendingAboveStopPrice;
            }

            if (pendingAboveTrailingDelta !== undefined && pendingAboveTrailingDelta !== null) {
                localVarQueryParameter['pendingAboveTrailingDelta'] = pendingAboveTrailingDelta;
            }

            if (pendingAboveIcebergQty !== undefined && pendingAboveIcebergQty !== null) {
                localVarQueryParameter['pendingAboveIcebergQty'] = pendingAboveIcebergQty;
            }

            if (pendingAboveTimeInForce !== undefined && pendingAboveTimeInForce !== null) {
                localVarQueryParameter['pendingAboveTimeInForce'] = pendingAboveTimeInForce;
            }

            if (pendingAboveStrategyId !== undefined && pendingAboveStrategyId !== null) {
                localVarQueryParameter['pendingAboveStrategyId'] = pendingAboveStrategyId;
            }

            if (pendingAboveStrategyType !== undefined && pendingAboveStrategyType !== null) {
                localVarQueryParameter['pendingAboveStrategyType'] = pendingAboveStrategyType;
            }

            if (pendingBelowType !== undefined && pendingBelowType !== null) {
                localVarQueryParameter['pendingBelowType'] = pendingBelowType;
            }

            if (pendingBelowClientOrderId !== undefined && pendingBelowClientOrderId !== null) {
                localVarQueryParameter['pendingBelowClientOrderId'] = pendingBelowClientOrderId;
            }

            if (pendingBelowPrice !== undefined && pendingBelowPrice !== null) {
                localVarQueryParameter['pendingBelowPrice'] = pendingBelowPrice;
            }

            if (pendingBelowStopPrice !== undefined && pendingBelowStopPrice !== null) {
                localVarQueryParameter['pendingBelowStopPrice'] = pendingBelowStopPrice;
            }

            if (pendingBelowTrailingDelta !== undefined && pendingBelowTrailingDelta !== null) {
                localVarQueryParameter['pendingBelowTrailingDelta'] = pendingBelowTrailingDelta;
            }

            if (pendingBelowIcebergQty !== undefined && pendingBelowIcebergQty !== null) {
                localVarQueryParameter['pendingBelowIcebergQty'] = pendingBelowIcebergQty;
            }

            if (pendingBelowTimeInForce !== undefined && pendingBelowTimeInForce !== null) {
                localVarQueryParameter['pendingBelowTimeInForce'] = pendingBelowTimeInForce;
            }

            if (pendingBelowStrategyId !== undefined && pendingBelowStrategyId !== null) {
                localVarQueryParameter['pendingBelowStrategyId'] = pendingBelowStrategyId;
            }

            if (pendingBelowStrategyType !== undefined && pendingBelowStrategyType !== null) {
                localVarQueryParameter['pendingBelowStrategyType'] = pendingBelowStrategyType;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList/otoco',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in a new OCO.
         *
         * Price Restrictions:
         * `SELL`: Limit Price > Last Price > Stop Price
         * `BUY`: Limit Price < Last Price < Stop Price
         * Quantity Restrictions:
         * Both legs must have the same quantity.
         * `ICEBERG` quantities however do not have to be the same
         * `OCO` adds **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
         * Weight: 1
         *
         * @summary New OCO - Deprecated
         * @param {string} symbol
         * @param {number} quantity
         * @param {number} stopPrice
         * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
         * @param {OrderOcoSideEnum} [side]
         * @param {string} [limitClientOrderId] A unique Id for the limit order
         * @param {number} [price]
         * @param {number} [limitStrategyId]
         * @param {number} [limitStrategyType] The value cannot be less than `1000000`.
         * @param {number} [limitIcebergQty] Used to make the `LIMIT_MAKER` leg an iceberg order.
         * @param {number} [trailingDelta]
         * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
         * @param {number} [stopStrategyId]
         * @param {number} [stopStrategyType] The value cannot be less than `1000000`.
         * @param {number} [stopLimitPrice] If provided, `stopLimitTimeInForce` is required.
         * @param {number} [stopIcebergQty] Used with `STOP_LOSS_LIMIT` leg to make an iceberg order.
         * @param {OrderOcoStopLimitTimeInForceEnum} [stopLimitTimeInForce]
         * @param {OrderOcoNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderOcoSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        orderOco: async (
            symbol: string,
            quantity: number,
            stopPrice: number,
            listClientOrderId?: string,
            side?: OrderOcoSideEnum,
            limitClientOrderId?: string,
            price?: number,
            limitStrategyId?: number,
            limitStrategyType?: number,
            limitIcebergQty?: number,
            trailingDelta?: number,
            stopClientOrderId?: string,
            stopStrategyId?: number,
            stopStrategyType?: number,
            stopLimitPrice?: number,
            stopIcebergQty?: number,
            stopLimitTimeInForce?: OrderOcoStopLimitTimeInForceEnum,
            newOrderRespType?: OrderOcoNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderOcoSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderOco', 'symbol', symbol);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('orderOco', 'quantity', quantity);
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('orderOco', 'stopPrice', stopPrice);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (limitClientOrderId !== undefined && limitClientOrderId !== null) {
                localVarQueryParameter['limitClientOrderId'] = limitClientOrderId;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (limitStrategyId !== undefined && limitStrategyId !== null) {
                localVarQueryParameter['limitStrategyId'] = limitStrategyId;
            }

            if (limitStrategyType !== undefined && limitStrategyType !== null) {
                localVarQueryParameter['limitStrategyType'] = limitStrategyType;
            }

            if (limitIcebergQty !== undefined && limitIcebergQty !== null) {
                localVarQueryParameter['limitIcebergQty'] = limitIcebergQty;
            }

            if (trailingDelta !== undefined && trailingDelta !== null) {
                localVarQueryParameter['trailingDelta'] = trailingDelta;
            }

            if (stopClientOrderId !== undefined && stopClientOrderId !== null) {
                localVarQueryParameter['stopClientOrderId'] = stopClientOrderId;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (stopStrategyId !== undefined && stopStrategyId !== null) {
                localVarQueryParameter['stopStrategyId'] = stopStrategyId;
            }

            if (stopStrategyType !== undefined && stopStrategyType !== null) {
                localVarQueryParameter['stopStrategyType'] = stopStrategyType;
            }

            if (stopLimitPrice !== undefined && stopLimitPrice !== null) {
                localVarQueryParameter['stopLimitPrice'] = stopLimitPrice;
            }

            if (stopIcebergQty !== undefined && stopIcebergQty !== null) {
                localVarQueryParameter['stopIcebergQty'] = stopIcebergQty;
            }

            if (stopLimitTimeInForce !== undefined && stopLimitTimeInForce !== null) {
                localVarQueryParameter['stopLimitTimeInForce'] = stopLimitTimeInForce;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order/oco',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test new order creation and signature/recvWindow long.
         * Creates and validates a new order but does not send it into the matching engine.
         * Weight: |Condition| Request Weight|
         * |------------           | ------------ |
         * |Without `computeCommissionRates`| 1|
         * |With `computeCommissionRates`|20|
         *
         * @summary Test new order
         * @param {boolean} [computeCommissionRates] Default: `false`
         *
         * @throws {RequiredError}
         */
        orderTest: async (computeCommissionRates?: boolean): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (computeCommissionRates !== undefined && computeCommissionRates !== null) {
                localVarQueryParameter['computeCommissionRates'] = computeCommissionRates;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order/test',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Places an order using smart order routing (SOR).
         * Weight: 1
         *
         * @summary New order using SOR
         * @param {string} symbol
         * @param {number} quantity
         * @param {SorOrderSideEnum} [side]
         * @param {SorOrderTypeEnum} [type]
         * @param {SorOrderTimeInForceEnum} [timeInForce]
         * @param {number} [price]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [strategyId]
         * @param {number} [strategyType] The value cannot be less than `1000000`.
         * @param {number} [icebergQty] Used with `LIMIT` to create an iceberg order.
         * @param {SorOrderNewOrderRespTypeEnum} [newOrderRespType]
         * @param {SorOrderSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {number} [recvWindow] The value cannot be greater than ```60000```
         *
         * @throws {RequiredError}
         */
        sorOrder: async (
            symbol: string,
            quantity: number,
            side?: SorOrderSideEnum,
            type?: SorOrderTypeEnum,
            timeInForce?: SorOrderTimeInForceEnum,
            price?: number,
            newClientOrderId?: string,
            strategyId?: number,
            strategyType?: number,
            icebergQty?: number,
            newOrderRespType?: SorOrderNewOrderRespTypeEnum,
            selfTradePreventionMode?: SorOrderSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('sorOrder', 'symbol', symbol);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('sorOrder', 'quantity', quantity);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (strategyType !== undefined && strategyType !== null) {
                localVarQueryParameter['strategyType'] = strategyType;
            }

            if (icebergQty !== undefined && icebergQty !== null) {
                localVarQueryParameter['icebergQty'] = icebergQty;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/sor/order',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test new order creation and signature/recvWindow using smart order routing (SOR).
         * Creates and validates a new order but does not send it into the matching engine.
         * Weight: | Condition | Request Weight |
         * | --------- | -------------- |
         * | Without `computeCommissionRates`  |  1 |
         * | With `computeCommissionRates`     | 20 |
         *
         * @summary Test new order using SOR
         * @param {boolean} [computeCommissionRates] Default: `false`
         *
         * @throws {RequiredError}
         */
        sorOrderTest: async (computeCommissionRates?: boolean): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (computeCommissionRates !== undefined && computeCommissionRates !== null) {
                localVarQueryParameter['computeCommissionRates'] = computeCommissionRates;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/sor/order/test',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * TradeApi - interface
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * Retrieves all order lists based on provided optional parameters.
     *
     * Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
     * Weight: 20
     *
     * @summary Query all Order lists
     * @param {AllOrderListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    allOrderList(
        requestParameters?: AllOrderListRequest
    ): Promise<RestApiResponse<AllOrderListResponse>>;
    /**
     * Get all account orders; active, canceled, or filled.
     * Weight: 20
     *
     * @summary All orders
     * @param {AllOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    allOrders(requestParameters: AllOrdersRequest): Promise<RestApiResponse<AllOrdersResponse>>;
    /**
     * Cancels all active orders on a symbol.
     * This includes orders that are part of an order list.
     * Weight: 1
     *
     * @summary Cancel All Open Orders on a Symbol
     * @param {DeleteOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    deleteOpenOrders(
        requestParameters: DeleteOpenOrdersRequest
    ): Promise<RestApiResponse<DeleteOpenOrdersResponse>>;
    /**
     * Cancel an active order.
     * Weight: 1
     *
     * @summary Cancel order
     * @param {DeleteOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    deleteOrder(
        requestParameters: DeleteOrderRequest
    ): Promise<RestApiResponse<DeleteOrderResponse>>;
    /**
     * Cancel an entire Order list
     * Weight: 1
     *
     * @summary Cancel Order list
     * @param {DeleteOrderListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    deleteOrderList(
        requestParameters: DeleteOrderListRequest
    ): Promise<RestApiResponse<DeleteOrderListResponse>>;
    /**
     * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
     * Weight: 6 for a single symbol; **80** when the symbol parameter is omitted
     *
     * @summary Current open orders
     * @param {GetOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getOpenOrders(
        requestParameters: GetOpenOrdersRequest
    ): Promise<RestApiResponse<GetOpenOrdersResponse>>;
    /**
     * Check an order's status.
     * Weight: 4
     *
     * @summary Query order
     * @param {GetOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getOrder(requestParameters: GetOrderRequest): Promise<RestApiResponse<GetOrderResponse>>;
    /**
     * Retrieves a specific order list based on provided optional parameters.
     * Weight: 4
     *
     * @summary Query Order list
     * @param {GetOrderListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getOrderList(
        requestParameters?: GetOrderListRequest
    ): Promise<RestApiResponse<GetOrderListResponse>>;
    /**
     * Send in a new order.
     * Weight: 1
     *
     * @summary New order
     * @param {NewOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newOrder(requestParameters: NewOrderRequest): Promise<RestApiResponse<NewOrderResponse>>;
    /**
     *
     * Weight: 6
     *
     * @summary Query Open Order lists
     * @param {OpenOrderListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    openOrderList(
        requestParameters?: OpenOrderListRequest
    ): Promise<RestApiResponse<OpenOrderListResponse>>;
    /**
     * Cancels an existing order and places a new order on the same symbol.
     *
     * Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
     *
     * A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED` ), will still increase the order count by 1.
     * Weight: 1
     *
     * @summary Cancel an Existing Order and Send a New Order
     * @param {OrderCancelReplaceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderCancelReplace(
        requestParameters: OrderCancelReplaceRequest
    ): Promise<RestApiResponse<OrderCancelReplaceResponse>>;
    /**
     * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
     *
     * An OCO has 2 orders called the **above order** and **below order**.
     * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
     * Price restrictions
     * If the OCO is on the `SELL` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
     * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * If the OCO is on the `BUY` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
     * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * OCOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter, and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New Order list - OCO
     * @param {OrderListOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderListOco(
        requestParameters: OrderListOcoRequest
    ): Promise<RestApiResponse<OrderListOcoResponse>>;
    /**
     * Places an OTO.
     *
     * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
     * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
     * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
     * OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New Order list - OTO
     * @param {OrderListOtoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderListOto(
        requestParameters: OrderListOtoRequest
    ): Promise<RestApiResponse<OrderListOtoResponse>>;
    /**
     * Place an OTOCO.
     *
     * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
     *
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
     * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
     * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
     * OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New Order list - OTOCO
     * @param {OrderListOtocoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderListOtoco(
        requestParameters: OrderListOtocoRequest
    ): Promise<RestApiResponse<OrderListOtocoResponse>>;
    /**
     * Send in a new OCO.
     *
     * Price Restrictions:
     * `SELL`: Limit Price > Last Price > Stop Price
     * `BUY`: Limit Price < Last Price < Stop Price
     * Quantity Restrictions:
     * Both legs must have the same quantity.
     * `ICEBERG` quantities however do not have to be the same
     * `OCO` adds **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New OCO - Deprecated
     * @param {OrderOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderOco(requestParameters: OrderOcoRequest): Promise<RestApiResponse<OrderOcoResponse>>;
    /**
     * Test new order creation and signature/recvWindow long.
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: |Condition| Request Weight|
     * |------------           | ------------ |
     * |Without `computeCommissionRates`| 1|
     * |With `computeCommissionRates`|20|
     *
     * @summary Test new order
     * @param {OrderTestRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderTest(requestParameters?: OrderTestRequest): Promise<RestApiResponse<void>>;
    /**
     * Places an order using smart order routing (SOR).
     * Weight: 1
     *
     * @summary New order using SOR
     * @param {SorOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    sorOrder(requestParameters: SorOrderRequest): Promise<RestApiResponse<SorOrderResponse>>;
    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR).
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: | Condition | Request Weight |
     * | --------- | -------------- |
     * | Without `computeCommissionRates`  |  1 |
     * | With `computeCommissionRates`     | 20 |
     *
     * @summary Test new order using SOR
     * @param {SorOrderTestRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    sorOrderTest(
        requestParameters?: SorOrderTestRequest
    ): Promise<RestApiResponse<SorOrderTestResponse>>;
}

/**
 * Request parameters for allOrderList operation in TradeApi.
 * @interface AllOrderListRequest
 */
export interface AllOrderListRequest {
    /**
     * TradeId to fetch from. Default gets most recent trades.
     * @type {number}
     * @memberof TradeApiAllOrderList
     */
    readonly fromId?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrderList
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrderList
     */
    readonly endTime?: number;

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradeApiAllOrderList
     */
    readonly limit?: number;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiAllOrderList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for allOrders operation in TradeApi.
 * @interface AllOrdersRequest
 */
export interface AllOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiAllOrders
     */
    readonly symbol: string;

    /**
     * This can only be used in combination with `symbol`.
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly orderId?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly endTime?: number;

    /**
     * Default 500; max 1000.
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly limit?: number;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for deleteOpenOrders operation in TradeApi.
 * @interface DeleteOpenOrdersRequest
 */
export interface DeleteOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiDeleteOpenOrders
     */
    readonly symbol: string;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiDeleteOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for deleteOrder operation in TradeApi.
 * @interface DeleteOrderRequest
 */
export interface DeleteOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiDeleteOrder
     */
    readonly symbol: string;

    /**
     * This can only be used in combination with `symbol`.
     * @type {number}
     * @memberof TradeApiDeleteOrder
     */
    readonly orderId?: number;

    /**
     * Either ```orderListId``` or ```listClientOrderId``` must be provided
     * @type {string}
     * @memberof TradeApiDeleteOrder
     */
    readonly origClientOrderId?: string;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiDeleteOrder
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {'ONLY_NEW' | 'NEW' | 'ONLY_PARTIALLY_FILLED' | 'PARTIALLY_FILLED'}
     * @memberof TradeApiDeleteOrder
     */
    readonly cancelRestrictions?: DeleteOrderCancelRestrictionsEnum;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiDeleteOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for deleteOrderList operation in TradeApi.
 * @interface DeleteOrderListRequest
 */
export interface DeleteOrderListRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiDeleteOrderList
     */
    readonly symbol: string;

    /**
     * Either```orderListId```or```listClientOrderId```mustbeprovided
     * @type {number}
     * @memberof TradeApiDeleteOrderList
     */
    readonly orderListId?: number;

    /**
     * Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @type {string}
     * @memberof TradeApiDeleteOrderList
     */
    readonly listClientOrderId?: string;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiDeleteOrderList
     */
    readonly newClientOrderId?: string;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiDeleteOrderList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getOpenOrders operation in TradeApi.
 * @interface GetOpenOrdersRequest
 */
export interface GetOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiGetOpenOrders
     */
    readonly symbol: string;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiGetOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getOrder operation in TradeApi.
 * @interface GetOrderRequest
 */
export interface GetOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiGetOrder
     */
    readonly symbol: string;

    /**
     * This can only be used in combination with `symbol`.
     * @type {number}
     * @memberof TradeApiGetOrder
     */
    readonly orderId?: number;

    /**
     * Either ```orderListId``` or ```listClientOrderId``` must be provided
     * @type {string}
     * @memberof TradeApiGetOrder
     */
    readonly origClientOrderId?: string;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiGetOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getOrderList operation in TradeApi.
 * @interface GetOrderListRequest
 */
export interface GetOrderListRequest {
    /**
     * Either```orderListId```or```listClientOrderId```mustbeprovided
     * @type {number}
     * @memberof TradeApiGetOrderList
     */
    readonly orderListId?: number;

    /**
     * Either ```orderListId``` or ```listClientOrderId``` must be provided
     * @type {string}
     * @memberof TradeApiGetOrderList
     */
    readonly origClientOrderId?: string;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiGetOrderList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for newOrder operation in TradeApi.
 * @interface NewOrderRequest
 */
export interface NewOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly quantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly stopPrice: number;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewOrder
     */
    readonly side?: NewOrderSideEnum;

    /**
     *
     * @type {'MARKET' | 'LIMIT' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT' | 'LIMIT_MAKER'}
     * @memberof TradeApiNewOrder
     */
    readonly type?: NewOrderTypeEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiNewOrder
     */
    readonly timeInForce?: NewOrderTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly quoteOrderQty?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly price?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly strategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly strategyType?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly trailingDelta?: number;

    /**
     * Used with `LIMIT` to create an iceberg order.
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly icebergQty?: number;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiNewOrder
     */
    readonly newOrderRespType?: NewOrderNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH'}
     * @memberof TradeApiNewOrder
     */
    readonly selfTradePreventionMode?: NewOrderSelfTradePreventionModeEnum;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for openOrderList operation in TradeApi.
 * @interface OpenOrderListRequest
 */
export interface OpenOrderListRequest {
    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiOpenOrderList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderCancelReplace operation in TradeApi.
 * @interface OrderCancelReplaceRequest
 */
export interface OrderCancelReplaceRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly quantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly stopPrice: number;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly side?: OrderCancelReplaceSideEnum;

    /**
     *
     * @type {'MARKET' | 'LIMIT' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT' | 'LIMIT_MAKER'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly type?: OrderCancelReplaceTypeEnum;

    /**
     *
     * @type {'STOP_ON_FAILURE' | 'ALLOW_FAILURE'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelReplaceMode?: OrderCancelReplaceCancelReplaceModeEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly timeInForce?: OrderCancelReplaceTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly quoteOrderQty?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly price?: number;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default.
     * @type {string}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelNewClientOrderId?: string;

    /**
     * Either the `cancelOrigClientOrderId` or `cancelOrderId` must be provided. If both are provided, `cancelOrderId` takes precedence.
     * @type {string}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelOrigClientOrderId?: string;

    /**
     * Either the `cancelOrigClientOrderId` or `cancelOrderId` must be provided. If both are provided, `cancelOrderId` takes precedence.
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelOrderId?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly strategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly strategyType?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly trailingDelta?: number;

    /**
     * Used with `LIMIT` to create an iceberg order.
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly icebergQty?: number;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly newOrderRespType?: OrderCancelReplaceNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly selfTradePreventionMode?: OrderCancelReplaceSelfTradePreventionModeEnum;

    /**
     *
     * @type {'ONLY_NEW' | 'NEW' | 'ONLY_PARTIALLY_FILLED' | 'PARTIALLY_FILLED'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelRestrictions?: OrderCancelReplaceCancelRestrictionsEnum;

    /**
     *
     * @type {'DO_NOTHING' | 'CANCEL_ONLY'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly orderRateLimitExceededMode?: OrderCancelReplaceOrderRateLimitExceededModeEnum;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderListOco operation in TradeApi.
 * @interface OrderListOcoRequest
 */
export interface OrderListOcoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderListOco
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly quantity: number;

    /**
     * Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @type {string}
     * @memberof TradeApiOrderListOco
     */
    readonly listClientOrderId?: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOco
     */
    readonly side?: OrderListOcoSideEnum;

    /**
     *
     * @type {'STOP_LOSS_LIMIT' | 'STOP_LOSS' | 'LIMIT_MAKER' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveType?: OrderListOcoAboveTypeEnum;

    /**
     * Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
     * @type {string}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveClientOrderId?: string;

    /**
     * Note that this can only be used if `aboveTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveIcebergQty?: number;

    /**
     * Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly abovePrice?: number;

    /**
     * Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT` <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveStopPrice?: number;

    /**
     * See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveTrailingDelta?: number;

    /**
     * Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveTimeInForce?: number;

    /**
     * Arbitrary numeric value identifying the above order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveStrategyType?: number;

    /**
     *
     * @type {'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOco
     */
    readonly belowType?: OrderListOcoBelowTypeEnum;

    /**
     * Arbitrary unique ID among open orders for the below order. Automatically generated if not sent
     * @type {string}
     * @memberof TradeApiOrderListOco
     */
    readonly belowClientOrderId?: string;

    /**
     * Note that this can only be used if `belowTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowIcebergQty?: number;

    /**
     * Can be used if `belowType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowPrice?: number;

    /**
     * Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT` or `TAKE_PROFIT_LIMIT` <br>Either belowStopPrice or belowTrailingDelta or both, must be specified.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowStopPrice?: number;

    /**
     * See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowTrailingDelta?: number;

    /**
     *
     * @type {'belowType' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOco
     */
    readonly belowTimeInForce?: OrderListOcoBelowTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the below order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowStrategyType?: number;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderListOco
     */
    readonly newOrderRespType?: OrderListOcoNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH'}
     * @memberof TradeApiOrderListOco
     */
    readonly selfTradePreventionMode?: OrderListOcoSelfTradePreventionModeEnum;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderListOto operation in TradeApi.
 * @interface OrderListOtoRequest
 */
export interface OrderListOtoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderListOto
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingPrice: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingQuantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingQuantity: number;

    /**
     * Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @type {string}
     * @memberof TradeApiOrderListOto
     */
    readonly listClientOrderId?: string;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderListOto
     */
    readonly newOrderRespType?: OrderListOtoNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH'}
     * @memberof TradeApiOrderListOto
     */
    readonly selfTradePreventionMode?: OrderListOtoSelfTradePreventionModeEnum;

    /**
     *
     * @type {'LIMIT' | 'LIMIT_MAKER'}
     * @memberof TradeApiOrderListOto
     */
    readonly workingType?: OrderListOtoWorkingTypeEnum;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOto
     */
    readonly workingSide?: OrderListOtoWorkingSideEnum;

    /**
     * Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOto
     */
    readonly workingClientOrderId?: string;

    /**
     * This can only be used if `workingTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOto
     */
    readonly workingTimeInForce?: OrderListOtoWorkingTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the working order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingStrategyType?: number;

    /**
     *
     * @type {'LIMIT' | 'MARKET' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT' | 'LIMIT_MAKER'}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingType?: OrderListOtoPendingTypeEnum;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingSide?: OrderListOtoPendingSideEnum;

    /**
     * Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingStopPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingTrailingDelta?: number;

    /**
     * This can only be used if `pendingTimeInForce` is `GTC` or if `pendingType` is `LIMIT_MAKER`.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingTimeInForce?: OrderListOtoPendingTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the pending order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingStrategyType?: number;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderListOtoco operation in TradeApi.
 * @interface OrderListOtocoRequest
 */
export interface OrderListOtocoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingPrice: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingQuantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingQuantity: number;

    /**
     * Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly listClientOrderId?: string;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly newOrderRespType?: OrderListOtocoNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly selfTradePreventionMode?: OrderListOtocoSelfTradePreventionModeEnum;

    /**
     *
     * @type {'LIMIT' | 'LIMIT_MAKER'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingType?: OrderListOtocoWorkingTypeEnum;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingSide?: OrderListOtocoWorkingSideEnum;

    /**
     * Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingClientOrderId?: string;

    /**
     * This can only be used if `workingTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingTimeInForce?: OrderListOtocoWorkingTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the working order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingStrategyType?: number;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingSide?: OrderListOtocoPendingSideEnum;

    /**
     *
     * @type {'STOP_LOSS_LIMIT' | 'STOP_LOSS' | 'LIMIT_MAKER' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveType?: OrderListOtocoPendingAboveTypeEnum;

    /**
     * Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveClientOrderId?: string;

    /**
     * Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAbovePrice?: number;

    /**
     * Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveStopPrice?: number;

    /**
     * See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveTrailingDelta?: number;

    /**
     * This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveTimeInForce?: OrderListOtocoPendingAboveTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the pending above order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveStrategyType?: number;

    /**
     *
     * @type {'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowType?: OrderListOtocoPendingBelowTypeEnum;

    /**
     * Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowClientOrderId?: string;

    /**
     * Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify limit price
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowPrice?: number;

    /**
     * Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br> Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowStopPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowTrailingDelta?: number;

    /**
     * This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowTimeInForce?: OrderListOtocoPendingBelowTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the pending below order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowStrategyType?: number;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderOco operation in TradeApi.
 * @interface OrderOcoRequest
 */
export interface OrderOcoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderOco
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly quantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopPrice: number;

    /**
     * Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @type {string}
     * @memberof TradeApiOrderOco
     */
    readonly listClientOrderId?: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderOco
     */
    readonly side?: OrderOcoSideEnum;

    /**
     * A unique Id for the limit order
     * @type {string}
     * @memberof TradeApiOrderOco
     */
    readonly limitClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly price?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly limitStrategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly limitStrategyType?: number;

    /**
     * Used to make the `LIMIT_MAKER` leg an iceberg order.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly limitIcebergQty?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly trailingDelta?: number;

    /**
     * A unique Id for the stop loss/stop loss limit leg
     * @type {string}
     * @memberof TradeApiOrderOco
     */
    readonly stopClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopStrategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopStrategyType?: number;

    /**
     * If provided, `stopLimitTimeInForce` is required.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopLimitPrice?: number;

    /**
     * Used with `STOP_LOSS_LIMIT` leg to make an iceberg order.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'FOK' | 'IOC'}
     * @memberof TradeApiOrderOco
     */
    readonly stopLimitTimeInForce?: OrderOcoStopLimitTimeInForceEnum;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderOco
     */
    readonly newOrderRespType?: OrderOcoNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH'}
     * @memberof TradeApiOrderOco
     */
    readonly selfTradePreventionMode?: OrderOcoSelfTradePreventionModeEnum;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderTest operation in TradeApi.
 * @interface OrderTestRequest
 */
export interface OrderTestRequest {
    /**
     * Default: `false`
     * @type {boolean}
     * @memberof TradeApiOrderTest
     */
    readonly computeCommissionRates?: boolean;
}

/**
 * Request parameters for sorOrder operation in TradeApi.
 * @interface SorOrderRequest
 */
export interface SorOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiSorOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly quantity: number;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiSorOrder
     */
    readonly side?: SorOrderSideEnum;

    /**
     *
     * @type {'MARKET' | 'LIMIT' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT' | 'LIMIT_MAKER'}
     * @memberof TradeApiSorOrder
     */
    readonly type?: SorOrderTypeEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiSorOrder
     */
    readonly timeInForce?: SorOrderTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly price?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiSorOrder
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly strategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly strategyType?: number;

    /**
     * Used with `LIMIT` to create an iceberg order.
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly icebergQty?: number;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiSorOrder
     */
    readonly newOrderRespType?: SorOrderNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH'}
     * @memberof TradeApiSorOrder
     */
    readonly selfTradePreventionMode?: SorOrderSelfTradePreventionModeEnum;

    /**
     * The value cannot be greater than ```60000```
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for sorOrderTest operation in TradeApi.
 * @interface SorOrderTestRequest
 */
export interface SorOrderTestRequest {
    /**
     * Default: `false`
     * @type {boolean}
     * @memberof TradeApiSorOrderTest
     */
    readonly computeCommissionRates?: boolean;
}

/**
 * TradeApi - object-oriented interface
 * @class TradeApi
 */
export class TradeApi implements TradeApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration);
    }

    /**
     * Retrieves all order lists based on provided optional parameters.
     *
     * Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
     * Weight: 20
     *
     * @summary Query all Order lists
     * @param {AllOrderListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AllOrderListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-all-order-lists-user_data Binance API Documentation}
     */
    public async allOrderList(
        requestParameters: AllOrderListRequest = {}
    ): Promise<RestApiResponse<AllOrderListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.allOrderList(
            requestParameters?.fromId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<AllOrderListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * Weight: 20
     *
     * @summary All orders
     * @param {AllOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AllOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#all-orders-user_data Binance API Documentation}
     */
    public async allOrders(
        requestParameters: AllOrdersRequest
    ): Promise<RestApiResponse<AllOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.allOrders(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<AllOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancels all active orders on a symbol.
     * This includes orders that are part of an order list.
     * Weight: 1
     *
     * @summary Cancel All Open Orders on a Symbol
     * @param {DeleteOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<DeleteOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-all-open-orders-on-a-symbol-trade Binance API Documentation}
     */
    public async deleteOpenOrders(
        requestParameters: DeleteOpenOrdersRequest
    ): Promise<RestApiResponse<DeleteOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<DeleteOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an active order.
     * Weight: 1
     *
     * @summary Cancel order
     * @param {DeleteOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<DeleteOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-trade Binance API Documentation}
     */
    public async deleteOrder(
        requestParameters: DeleteOrderRequest
    ): Promise<RestApiResponse<DeleteOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.cancelRestrictions,
            requestParameters?.recvWindow
        );
        return sendRequest<DeleteOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an entire Order list
     * Weight: 1
     *
     * @summary Cancel Order list
     * @param {DeleteOrderListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<DeleteOrderListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-list-trade Binance API Documentation}
     */
    public async deleteOrderList(
        requestParameters: DeleteOrderListRequest
    ): Promise<RestApiResponse<DeleteOrderListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteOrderList(
            requestParameters?.symbol,
            requestParameters?.orderListId,
            requestParameters?.listClientOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<DeleteOrderListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
     * Weight: 6 for a single symbol; **80** when the symbol parameter is omitted
     *
     * @summary Current open orders
     * @param {GetOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#current-open-orders-user_data Binance API Documentation}
     */
    public async getOpenOrders(
        requestParameters: GetOpenOrdersRequest
    ): Promise<RestApiResponse<GetOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<GetOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Check an order's status.
     * Weight: 4
     *
     * @summary Query order
     * @param {GetOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-order-user_data Binance API Documentation}
     */
    public async getOrder(
        requestParameters: GetOrderRequest
    ): Promise<RestApiResponse<GetOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<GetOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Retrieves a specific order list based on provided optional parameters.
     * Weight: 4
     *
     * @summary Query Order list
     * @param {GetOrderListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetOrderListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-order-list-user_data Binance API Documentation}
     */
    public async getOrderList(
        requestParameters: GetOrderListRequest = {}
    ): Promise<RestApiResponse<GetOrderListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOrderList(
            requestParameters?.orderListId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<GetOrderListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in a new order.
     * Weight: 1
     *
     * @summary New order
     * @param {NewOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade Binance API Documentation}
     */
    public async newOrder(
        requestParameters: NewOrderRequest
    ): Promise<RestApiResponse<NewOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newOrder(
            requestParameters?.symbol,
            requestParameters?.quantity,
            requestParameters?.stopPrice,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.timeInForce,
            requestParameters?.quoteOrderQty,
            requestParameters?.price,
            requestParameters?.newClientOrderId,
            requestParameters?.strategyId,
            requestParameters?.strategyType,
            requestParameters?.trailingDelta,
            requestParameters?.icebergQty,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<NewOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     *
     * Weight: 6
     *
     * @summary Query Open Order lists
     * @param {OpenOrderListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OpenOrderListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-open-order-lists-user_data Binance API Documentation}
     */
    public async openOrderList(
        requestParameters: OpenOrderListRequest = {}
    ): Promise<RestApiResponse<OpenOrderListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.openOrderList(
            requestParameters?.recvWindow
        );
        return sendRequest<OpenOrderListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancels an existing order and places a new order on the same symbol.
     *
     * Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
     *
     * A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED` ), will still increase the order count by 1.
     * Weight: 1
     *
     * @summary Cancel an Existing Order and Send a New Order
     * @param {OrderCancelReplaceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderCancelReplaceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-an-existing-order-and-send-a-new-order-trade Binance API Documentation}
     */
    public async orderCancelReplace(
        requestParameters: OrderCancelReplaceRequest
    ): Promise<RestApiResponse<OrderCancelReplaceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderCancelReplace(
            requestParameters?.symbol,
            requestParameters?.quantity,
            requestParameters?.stopPrice,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.cancelReplaceMode,
            requestParameters?.timeInForce,
            requestParameters?.quoteOrderQty,
            requestParameters?.price,
            requestParameters?.cancelNewClientOrderId,
            requestParameters?.cancelOrigClientOrderId,
            requestParameters?.cancelOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.strategyId,
            requestParameters?.strategyType,
            requestParameters?.trailingDelta,
            requestParameters?.icebergQty,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.cancelRestrictions,
            requestParameters?.orderRateLimitExceededMode,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderCancelReplaceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
     *
     * An OCO has 2 orders called the **above order** and **below order**.
     * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
     * Price restrictions
     * If the OCO is on the `SELL` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
     * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * If the OCO is on the `BUY` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
     * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * OCOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter, and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New Order list - OCO
     * @param {OrderListOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderListOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade Binance API Documentation}
     */
    public async orderListOco(
        requestParameters: OrderListOcoRequest
    ): Promise<RestApiResponse<OrderListOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderListOco(
            requestParameters?.symbol,
            requestParameters?.quantity,
            requestParameters?.listClientOrderId,
            requestParameters?.side,
            requestParameters?.aboveType,
            requestParameters?.aboveClientOrderId,
            requestParameters?.aboveIcebergQty,
            requestParameters?.abovePrice,
            requestParameters?.aboveStopPrice,
            requestParameters?.aboveTrailingDelta,
            requestParameters?.aboveTimeInForce,
            requestParameters?.aboveStrategyId,
            requestParameters?.aboveStrategyType,
            requestParameters?.belowType,
            requestParameters?.belowClientOrderId,
            requestParameters?.belowIcebergQty,
            requestParameters?.belowPrice,
            requestParameters?.belowStopPrice,
            requestParameters?.belowTrailingDelta,
            requestParameters?.belowTimeInForce,
            requestParameters?.belowStrategyId,
            requestParameters?.belowStrategyType,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderListOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Places an OTO.
     *
     * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
     * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
     * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
     * OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New Order list - OTO
     * @param {OrderListOtoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderListOtoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oto-trade Binance API Documentation}
     */
    public async orderListOto(
        requestParameters: OrderListOtoRequest
    ): Promise<RestApiResponse<OrderListOtoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderListOto(
            requestParameters?.symbol,
            requestParameters?.workingPrice,
            requestParameters?.workingQuantity,
            requestParameters?.pendingQuantity,
            requestParameters?.listClientOrderId,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.workingType,
            requestParameters?.workingSide,
            requestParameters?.workingClientOrderId,
            requestParameters?.workingIcebergQty,
            requestParameters?.workingTimeInForce,
            requestParameters?.workingStrategyId,
            requestParameters?.workingStrategyType,
            requestParameters?.pendingType,
            requestParameters?.pendingSide,
            requestParameters?.pendingClientOrderId,
            requestParameters?.pendingPrice,
            requestParameters?.pendingStopPrice,
            requestParameters?.pendingTrailingDelta,
            requestParameters?.pendingIcebergQty,
            requestParameters?.pendingTimeInForce,
            requestParameters?.pendingStrategyId,
            requestParameters?.pendingStrategyType,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderListOtoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Place an OTOCO.
     *
     * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
     *
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
     * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
     * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
     * OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New Order list - OTOCO
     * @param {OrderListOtocoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderListOtocoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---otoco-trade Binance API Documentation}
     */
    public async orderListOtoco(
        requestParameters: OrderListOtocoRequest
    ): Promise<RestApiResponse<OrderListOtocoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderListOtoco(
            requestParameters?.symbol,
            requestParameters?.workingPrice,
            requestParameters?.workingQuantity,
            requestParameters?.pendingQuantity,
            requestParameters?.listClientOrderId,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.workingType,
            requestParameters?.workingSide,
            requestParameters?.workingClientOrderId,
            requestParameters?.workingIcebergQty,
            requestParameters?.workingTimeInForce,
            requestParameters?.workingStrategyId,
            requestParameters?.workingStrategyType,
            requestParameters?.pendingSide,
            requestParameters?.pendingAboveType,
            requestParameters?.pendingAboveClientOrderId,
            requestParameters?.pendingAbovePrice,
            requestParameters?.pendingAboveStopPrice,
            requestParameters?.pendingAboveTrailingDelta,
            requestParameters?.pendingAboveIcebergQty,
            requestParameters?.pendingAboveTimeInForce,
            requestParameters?.pendingAboveStrategyId,
            requestParameters?.pendingAboveStrategyType,
            requestParameters?.pendingBelowType,
            requestParameters?.pendingBelowClientOrderId,
            requestParameters?.pendingBelowPrice,
            requestParameters?.pendingBelowStopPrice,
            requestParameters?.pendingBelowTrailingDelta,
            requestParameters?.pendingBelowIcebergQty,
            requestParameters?.pendingBelowTimeInForce,
            requestParameters?.pendingBelowStrategyId,
            requestParameters?.pendingBelowStrategyType,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderListOtocoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in a new OCO.
     *
     * Price Restrictions:
     * `SELL`: Limit Price > Last Price > Stop Price
     * `BUY`: Limit Price < Last Price < Stop Price
     * Quantity Restrictions:
     * Both legs must have the same quantity.
     * `ICEBERG` quantities however do not have to be the same
     * `OCO` adds **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New OCO - Deprecated
     * @param {OrderOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-oco---deprecated-trade Binance API Documentation}
     */
    public async orderOco(
        requestParameters: OrderOcoRequest
    ): Promise<RestApiResponse<OrderOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderOco(
            requestParameters?.symbol,
            requestParameters?.quantity,
            requestParameters?.stopPrice,
            requestParameters?.listClientOrderId,
            requestParameters?.side,
            requestParameters?.limitClientOrderId,
            requestParameters?.price,
            requestParameters?.limitStrategyId,
            requestParameters?.limitStrategyType,
            requestParameters?.limitIcebergQty,
            requestParameters?.trailingDelta,
            requestParameters?.stopClientOrderId,
            requestParameters?.stopStrategyId,
            requestParameters?.stopStrategyType,
            requestParameters?.stopLimitPrice,
            requestParameters?.stopIcebergQty,
            requestParameters?.stopLimitTimeInForce,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Test new order creation and signature/recvWindow long.
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: |Condition| Request Weight|
     * |------------           | ------------ |
     * |Without `computeCommissionRates`| 1|
     * |With `computeCommissionRates`|20|
     *
     * @summary Test new order
     * @param {OrderTestRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<void>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-trade Binance API Documentation}
     */
    public async orderTest(
        requestParameters: OrderTestRequest = {}
    ): Promise<RestApiResponse<void>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderTest(
            requestParameters?.computeCommissionRates
        );
        return sendRequest<void>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Places an order using smart order routing (SOR).
     * Weight: 1
     *
     * @summary New order using SOR
     * @param {SorOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SorOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-using-sor-trade Binance API Documentation}
     */
    public async sorOrder(
        requestParameters: SorOrderRequest
    ): Promise<RestApiResponse<SorOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.sorOrder(
            requestParameters?.symbol,
            requestParameters?.quantity,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.timeInForce,
            requestParameters?.price,
            requestParameters?.newClientOrderId,
            requestParameters?.strategyId,
            requestParameters?.strategyType,
            requestParameters?.icebergQty,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<SorOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR).
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: | Condition | Request Weight |
     * | --------- | -------------- |
     * | Without `computeCommissionRates`  |  1 |
     * | With `computeCommissionRates`     | 20 |
     *
     * @summary Test new order using SOR
     * @param {SorOrderTestRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SorOrderTestResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-using-sor-trade Binance API Documentation}
     */
    public async sorOrderTest(
        requestParameters: SorOrderTestRequest = {}
    ): Promise<RestApiResponse<SorOrderTestResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.sorOrderTest(
            requestParameters?.computeCommissionRates
        );
        return sendRequest<SorOrderTestResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}

export const DeleteOrderCancelRestrictionsEnum = {
    ONLY_NEW: 'ONLY_NEW',
    NEW: 'NEW',
    ONLY_PARTIALLY_FILLED: 'ONLY_PARTIALLY_FILLED',
    PARTIALLY_FILLED: 'PARTIALLY_FILLED',
} as const;
export type DeleteOrderCancelRestrictionsEnum =
    (typeof DeleteOrderCancelRestrictionsEnum)[keyof typeof DeleteOrderCancelRestrictionsEnum];

export const NewOrderSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type NewOrderSideEnum = (typeof NewOrderSideEnum)[keyof typeof NewOrderSideEnum];

export const NewOrderTypeEnum = {
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
    STOP_LOSS: 'STOP_LOSS',
    STOP_LOSS_LIMIT: 'STOP_LOSS_LIMIT',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT: 'TAKE_PROFIT_LIMIT',
    LIMIT_MAKER: 'LIMIT_MAKER',
} as const;
export type NewOrderTypeEnum = (typeof NewOrderTypeEnum)[keyof typeof NewOrderTypeEnum];

export const NewOrderTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type NewOrderTimeInForceEnum =
    (typeof NewOrderTimeInForceEnum)[keyof typeof NewOrderTimeInForceEnum];

export const NewOrderNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
} as const;
export type NewOrderNewOrderRespTypeEnum =
    (typeof NewOrderNewOrderRespTypeEnum)[keyof typeof NewOrderNewOrderRespTypeEnum];

export const NewOrderSelfTradePreventionModeEnum = {
    NONE: 'NONE',
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
} as const;
export type NewOrderSelfTradePreventionModeEnum =
    (typeof NewOrderSelfTradePreventionModeEnum)[keyof typeof NewOrderSelfTradePreventionModeEnum];

export const OrderCancelReplaceSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type OrderCancelReplaceSideEnum =
    (typeof OrderCancelReplaceSideEnum)[keyof typeof OrderCancelReplaceSideEnum];

export const OrderCancelReplaceTypeEnum = {
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
    STOP_LOSS: 'STOP_LOSS',
    STOP_LOSS_LIMIT: 'STOP_LOSS_LIMIT',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT: 'TAKE_PROFIT_LIMIT',
    LIMIT_MAKER: 'LIMIT_MAKER',
} as const;
export type OrderCancelReplaceTypeEnum =
    (typeof OrderCancelReplaceTypeEnum)[keyof typeof OrderCancelReplaceTypeEnum];

export const OrderCancelReplaceCancelReplaceModeEnum = {
    STOP_ON_FAILURE: 'STOP_ON_FAILURE',
    ALLOW_FAILURE: 'ALLOW_FAILURE',
} as const;
export type OrderCancelReplaceCancelReplaceModeEnum =
    (typeof OrderCancelReplaceCancelReplaceModeEnum)[keyof typeof OrderCancelReplaceCancelReplaceModeEnum];

export const OrderCancelReplaceTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type OrderCancelReplaceTimeInForceEnum =
    (typeof OrderCancelReplaceTimeInForceEnum)[keyof typeof OrderCancelReplaceTimeInForceEnum];

export const OrderCancelReplaceNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
} as const;
export type OrderCancelReplaceNewOrderRespTypeEnum =
    (typeof OrderCancelReplaceNewOrderRespTypeEnum)[keyof typeof OrderCancelReplaceNewOrderRespTypeEnum];

export const OrderCancelReplaceSelfTradePreventionModeEnum = {
    NONE: 'NONE',
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
} as const;
export type OrderCancelReplaceSelfTradePreventionModeEnum =
    (typeof OrderCancelReplaceSelfTradePreventionModeEnum)[keyof typeof OrderCancelReplaceSelfTradePreventionModeEnum];

export const OrderCancelReplaceCancelRestrictionsEnum = {
    ONLY_NEW: 'ONLY_NEW',
    NEW: 'NEW',
    ONLY_PARTIALLY_FILLED: 'ONLY_PARTIALLY_FILLED',
    PARTIALLY_FILLED: 'PARTIALLY_FILLED',
} as const;
export type OrderCancelReplaceCancelRestrictionsEnum =
    (typeof OrderCancelReplaceCancelRestrictionsEnum)[keyof typeof OrderCancelReplaceCancelRestrictionsEnum];

export const OrderCancelReplaceOrderRateLimitExceededModeEnum = {
    DO_NOTHING: 'DO_NOTHING',
    CANCEL_ONLY: 'CANCEL_ONLY',
} as const;
export type OrderCancelReplaceOrderRateLimitExceededModeEnum =
    (typeof OrderCancelReplaceOrderRateLimitExceededModeEnum)[keyof typeof OrderCancelReplaceOrderRateLimitExceededModeEnum];

export const OrderListOcoSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type OrderListOcoSideEnum = (typeof OrderListOcoSideEnum)[keyof typeof OrderListOcoSideEnum];

export const OrderListOcoAboveTypeEnum = {
    STOP_LOSS_LIMIT: 'STOP_LOSS_LIMIT',
    STOP_LOSS: 'STOP_LOSS',
    LIMIT_MAKER: 'LIMIT_MAKER',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT: 'TAKE_PROFIT_LIMIT',
} as const;
export type OrderListOcoAboveTypeEnum =
    (typeof OrderListOcoAboveTypeEnum)[keyof typeof OrderListOcoAboveTypeEnum];

export const OrderListOcoBelowTypeEnum = {
    STOP_LOSS: 'STOP_LOSS',
    STOP_LOSS_LIMIT: 'STOP_LOSS_LIMIT',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT: 'TAKE_PROFIT_LIMIT',
} as const;
export type OrderListOcoBelowTypeEnum =
    (typeof OrderListOcoBelowTypeEnum)[keyof typeof OrderListOcoBelowTypeEnum];

export const OrderListOcoBelowTimeInForceEnum = {
    belowType: 'belowType',
    STOP_LOSS_LIMIT: 'STOP_LOSS_LIMIT',
    TAKE_PROFIT_LIMIT: 'TAKE_PROFIT_LIMIT',
} as const;
export type OrderListOcoBelowTimeInForceEnum =
    (typeof OrderListOcoBelowTimeInForceEnum)[keyof typeof OrderListOcoBelowTimeInForceEnum];

export const OrderListOcoNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
} as const;
export type OrderListOcoNewOrderRespTypeEnum =
    (typeof OrderListOcoNewOrderRespTypeEnum)[keyof typeof OrderListOcoNewOrderRespTypeEnum];

export const OrderListOcoSelfTradePreventionModeEnum = {
    NONE: 'NONE',
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
} as const;
export type OrderListOcoSelfTradePreventionModeEnum =
    (typeof OrderListOcoSelfTradePreventionModeEnum)[keyof typeof OrderListOcoSelfTradePreventionModeEnum];

export const OrderListOtoNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
} as const;
export type OrderListOtoNewOrderRespTypeEnum =
    (typeof OrderListOtoNewOrderRespTypeEnum)[keyof typeof OrderListOtoNewOrderRespTypeEnum];

export const OrderListOtoSelfTradePreventionModeEnum = {
    NONE: 'NONE',
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
} as const;
export type OrderListOtoSelfTradePreventionModeEnum =
    (typeof OrderListOtoSelfTradePreventionModeEnum)[keyof typeof OrderListOtoSelfTradePreventionModeEnum];

export const OrderListOtoWorkingTypeEnum = {
    LIMIT: 'LIMIT',
    LIMIT_MAKER: 'LIMIT_MAKER',
} as const;
export type OrderListOtoWorkingTypeEnum =
    (typeof OrderListOtoWorkingTypeEnum)[keyof typeof OrderListOtoWorkingTypeEnum];

export const OrderListOtoWorkingSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type OrderListOtoWorkingSideEnum =
    (typeof OrderListOtoWorkingSideEnum)[keyof typeof OrderListOtoWorkingSideEnum];

export const OrderListOtoWorkingTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type OrderListOtoWorkingTimeInForceEnum =
    (typeof OrderListOtoWorkingTimeInForceEnum)[keyof typeof OrderListOtoWorkingTimeInForceEnum];

export const OrderListOtoPendingTypeEnum = {
    LIMIT: 'LIMIT',
    MARKET: 'MARKET',
    STOP_LOSS: 'STOP_LOSS',
    STOP_LOSS_LIMIT: 'STOP_LOSS_LIMIT',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT: 'TAKE_PROFIT_LIMIT',
    LIMIT_MAKER: 'LIMIT_MAKER',
} as const;
export type OrderListOtoPendingTypeEnum =
    (typeof OrderListOtoPendingTypeEnum)[keyof typeof OrderListOtoPendingTypeEnum];

export const OrderListOtoPendingSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type OrderListOtoPendingSideEnum =
    (typeof OrderListOtoPendingSideEnum)[keyof typeof OrderListOtoPendingSideEnum];

export const OrderListOtoPendingTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type OrderListOtoPendingTimeInForceEnum =
    (typeof OrderListOtoPendingTimeInForceEnum)[keyof typeof OrderListOtoPendingTimeInForceEnum];

export const OrderListOtocoNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
} as const;
export type OrderListOtocoNewOrderRespTypeEnum =
    (typeof OrderListOtocoNewOrderRespTypeEnum)[keyof typeof OrderListOtocoNewOrderRespTypeEnum];

export const OrderListOtocoSelfTradePreventionModeEnum = {
    NONE: 'NONE',
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
} as const;
export type OrderListOtocoSelfTradePreventionModeEnum =
    (typeof OrderListOtocoSelfTradePreventionModeEnum)[keyof typeof OrderListOtocoSelfTradePreventionModeEnum];

export const OrderListOtocoWorkingTypeEnum = {
    LIMIT: 'LIMIT',
    LIMIT_MAKER: 'LIMIT_MAKER',
} as const;
export type OrderListOtocoWorkingTypeEnum =
    (typeof OrderListOtocoWorkingTypeEnum)[keyof typeof OrderListOtocoWorkingTypeEnum];

export const OrderListOtocoWorkingSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type OrderListOtocoWorkingSideEnum =
    (typeof OrderListOtocoWorkingSideEnum)[keyof typeof OrderListOtocoWorkingSideEnum];

export const OrderListOtocoWorkingTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type OrderListOtocoWorkingTimeInForceEnum =
    (typeof OrderListOtocoWorkingTimeInForceEnum)[keyof typeof OrderListOtocoWorkingTimeInForceEnum];

export const OrderListOtocoPendingSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type OrderListOtocoPendingSideEnum =
    (typeof OrderListOtocoPendingSideEnum)[keyof typeof OrderListOtocoPendingSideEnum];

export const OrderListOtocoPendingAboveTypeEnum = {
    STOP_LOSS_LIMIT: 'STOP_LOSS_LIMIT',
    STOP_LOSS: 'STOP_LOSS',
    LIMIT_MAKER: 'LIMIT_MAKER',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT: 'TAKE_PROFIT_LIMIT',
} as const;
export type OrderListOtocoPendingAboveTypeEnum =
    (typeof OrderListOtocoPendingAboveTypeEnum)[keyof typeof OrderListOtocoPendingAboveTypeEnum];

export const OrderListOtocoPendingAboveTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type OrderListOtocoPendingAboveTimeInForceEnum =
    (typeof OrderListOtocoPendingAboveTimeInForceEnum)[keyof typeof OrderListOtocoPendingAboveTimeInForceEnum];

export const OrderListOtocoPendingBelowTypeEnum = {
    STOP_LOSS: 'STOP_LOSS',
    STOP_LOSS_LIMIT: 'STOP_LOSS_LIMIT',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT: 'TAKE_PROFIT_LIMIT',
} as const;
export type OrderListOtocoPendingBelowTypeEnum =
    (typeof OrderListOtocoPendingBelowTypeEnum)[keyof typeof OrderListOtocoPendingBelowTypeEnum];

export const OrderListOtocoPendingBelowTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type OrderListOtocoPendingBelowTimeInForceEnum =
    (typeof OrderListOtocoPendingBelowTimeInForceEnum)[keyof typeof OrderListOtocoPendingBelowTimeInForceEnum];

export const OrderOcoSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type OrderOcoSideEnum = (typeof OrderOcoSideEnum)[keyof typeof OrderOcoSideEnum];

export const OrderOcoStopLimitTimeInForceEnum = {
    GTC: 'GTC',
    FOK: 'FOK',
    IOC: 'IOC',
} as const;
export type OrderOcoStopLimitTimeInForceEnum =
    (typeof OrderOcoStopLimitTimeInForceEnum)[keyof typeof OrderOcoStopLimitTimeInForceEnum];

export const OrderOcoNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
} as const;
export type OrderOcoNewOrderRespTypeEnum =
    (typeof OrderOcoNewOrderRespTypeEnum)[keyof typeof OrderOcoNewOrderRespTypeEnum];

export const OrderOcoSelfTradePreventionModeEnum = {
    NONE: 'NONE',
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
} as const;
export type OrderOcoSelfTradePreventionModeEnum =
    (typeof OrderOcoSelfTradePreventionModeEnum)[keyof typeof OrderOcoSelfTradePreventionModeEnum];

export const SorOrderSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type SorOrderSideEnum = (typeof SorOrderSideEnum)[keyof typeof SorOrderSideEnum];

export const SorOrderTypeEnum = {
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
    STOP_LOSS: 'STOP_LOSS',
    STOP_LOSS_LIMIT: 'STOP_LOSS_LIMIT',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT: 'TAKE_PROFIT_LIMIT',
    LIMIT_MAKER: 'LIMIT_MAKER',
} as const;
export type SorOrderTypeEnum = (typeof SorOrderTypeEnum)[keyof typeof SorOrderTypeEnum];

export const SorOrderTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type SorOrderTimeInForceEnum =
    (typeof SorOrderTimeInForceEnum)[keyof typeof SorOrderTimeInForceEnum];

export const SorOrderNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
    MARKET: 'MARKET',
    LIMIT: 'LIMIT',
} as const;
export type SorOrderNewOrderRespTypeEnum =
    (typeof SorOrderNewOrderRespTypeEnum)[keyof typeof SorOrderNewOrderRespTypeEnum];

export const SorOrderSelfTradePreventionModeEnum = {
    NONE: 'NONE',
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
} as const;
export type SorOrderSelfTradePreventionModeEnum =
    (typeof SorOrderSelfTradePreventionModeEnum)[keyof typeof SorOrderSelfTradePreventionModeEnum];
